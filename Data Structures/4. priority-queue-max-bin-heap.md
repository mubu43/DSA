# Priority Queue using Binary Max-Heap

## Overview

A **Priority Queue** is an abstract data type where elements are served based on their **priority** rather than insertion order. We implement this using a **Binary Max-Heap** where larger values have higher priority.

## What is a Binary Max-Heap?

A **Binary Max-Heap** is a complete binary tree with the following properties:

### 1. **Shape Property**
- Complete binary tree (all levels filled except possibly the last)
- Last level filled from left to right

### 2. **Max-Heap Property**
- Every parent node ≥ its children nodes
- The **maximum element** is always at the root

### 3. **Array Representation**
We store the heap in an array using these index relationships:
- **Parent of node i**: `(i - 1) / 2`
- **Left child of node i**: `2 * i + 1`
- **Right child of node i**: `2 * i + 2`

## Building a Max-Heap: Step-by-Step Example

Let's build a max-heap by inserting: **10, 20, 15, 30, 40, 25, 35**

### Step 1: Insert 10
```
Array: [10]
Tree:   10
```
- First element becomes root
- Heap property satisfied (trivially)

### Step 2: Insert 20
```
Array: [10, 20]
Tree:   10
       /
      20
```
- Add 20 as left child of 10
- **Violation**: Child (20) > Parent (10)
- **Swim operation needed**

**Swim Operation:**
1. Compare 20 with parent 10
2. 20 > 10, so swap them
3. Result: `[20, 10]`

```
After swim:
Array: [20, 10]
Tree:   20
       /
      10
```

### Step 3: Insert 15
```
Array: [20, 10, 15]
Tree:   20
       / \
      10  15
```
- Add 15 as right child of 20
- Check: 15 ≤ 20 ✓ (heap property satisfied)
- No swim needed

### Step 4: Insert 30
```
Array: [20, 10, 15, 30]
Tree:    20
       /  \
      10   15
     /
    30
```
- Add 30 as left child of 10
- **Violation**: Child (30) > Parent (10)
- **Swim operation needed**

**Swim Operation:**
1. Compare 30 with parent 10 → 30 > 10, swap
2. Array becomes: `[20, 30, 15, 10]`
3. Compare 30 with new parent 20 → 30 > 20, swap
4. Final array: `[30, 20, 15, 10]`

```
After swim:
Array: [30, 20, 15, 10]
Tree:    30
       /  \
      20   15
     /
    10
```

### Step 5: Insert 40
```
Array: [30, 20, 15, 10, 40]
Tree:    30
       /  \
      20   15
     / \
    10  40
```
- Add 40 as right child of 20
- **Violation**: Child (40) > Parent (20)
- **Swim operation needed**

**Swim Operation:**
1. Compare 40 with parent 20 → 40 > 20, swap
2. Array becomes: `[30, 40, 15, 10, 20]`
3. Compare 40 with new parent 30 → 40 > 30, swap
4. Final array: `[40, 30, 15, 10, 20]`

```
After swim:
Array: [40, 30, 15, 10, 20]
Tree:    40
       /  \
      30   15
     / \
    10  20
```

### Step 6: Insert 25
```
Array: [40, 30, 15, 10, 20, 25]
Tree:    40
       /  \
      30   15
     / \   /
    10  20 25
```
- Add 25 as left child of 15
- **Violation**: Child (25) > Parent (15)
- **Swim operation needed**

**Swim Operation:**
1. Compare 25 with parent 15 → 25 > 15, swap
2. Array becomes: `[40, 30, 25, 10, 20, 15]`
3. Compare 25 with new parent 40 → 25 ≤ 40 ✓
4. Swim complete

```
After swim:
Array: [40, 30, 25, 10, 20, 15]
Tree:    40
       /  \
      30   25
     / \   /
    10  20 15
```

### Step 7: Insert 35
```
Array: [40, 30, 25, 10, 20, 15, 35]
Tree:    40
       /  \
      30   25
     / \   / \
    10  20 15 35
```
- Add 35 as right child of 25
- **Violation**: Child (35) > Parent (25)
- **Swim operation needed**

**Swim Operation:**
1. Compare 35 with parent 25 → 35 > 25, swap
2. Array becomes: `[40, 30, 35, 10, 20, 15, 25]`
3. Compare 35 with new parent 40 → 35 ≤ 40 ✓
4. Swim complete

```
Final Heap:
Array: [40, 30, 35, 10, 20, 15, 25]
Tree:    40
       /  \
      30   35
     / \   / \
    10  20 15 25
```

## Swim Operation (Bottom-Up Heapify)

**Purpose**: Restore heap property after insertion

**Algorithm**:
1. Start from newly inserted element
2. While current element > parent:
   - Swap current with parent
   - Move up to parent position
3. Stop when heap property satisfied or reach root

**Time Complexity**: O(log n) - maximum height of tree

**Example**: Inserting 50 into our heap `[40, 30, 35, 10, 20, 15, 25]`

```
Step 1: Insert at end
[40, 30, 35, 10, 20, 15, 25, 50]
         40
       /    \
      30     35
     / \    / \
    10  20 15  25
   /
  50

Step 2: Compare 50 with parent 10
50 > 10 → Swap
[40, 30, 35, 50, 20, 15, 25, 10]

Step 3: Compare 50 with parent 30  
50 > 30 → Swap
[40, 50, 35, 30, 20, 15, 25, 10]

Step 4: Compare 50 with parent 40
50 > 40 → Swap
[50, 40, 35, 30, 20, 15, 25, 10]

Final result:
         50
       /    \
      40     35
     / \    / \
    30  20 15  25
   /
  10
```

## Sink Operation (Top-Down Heapify)

**Purpose**: Restore heap property after extraction

**Algorithm**:
1. Start from given position (usually root)
2. While current element < largest child:
   - Find largest among current and its children
   - Swap current with largest child
   - Move down to largest child position
3. Stop when heap property satisfied or reach leaf

**Time Complexity**: O(log n) - maximum height of tree

## Extract Max (Dequeue) Operation

**Purpose**: Remove and return the highest priority element

**Algorithm**:
1. Save root element (maximum)
2. Move last element to root position
3. Remove last element (reduce heap size)
4. **Sink** from root to restore heap property

**Example**: Extract max from `[50, 40, 35, 30, 20, 15, 25, 10]`

```
Step 1: Save max (50) and move last element (10) to root
[10, 40, 35, 30, 20, 15, 25]  (removed last element)
         10
       /    \
      40     35
     / \    / \
    30  20 15  25

Step 2: Sink operation - compare 10 with children 40 and 35
Largest = 40, so swap 10 with 40
[40, 10, 35, 30, 20, 15, 25]
         40
       /    \
      10     35
     / \    / \
    30  20 15  25

Step 3: Continue sinking - compare 10 with children 30 and 20
Largest = 30, so swap 10 with 30
[40, 30, 35, 10, 20, 15, 25]
         40
       /    \
      30     35
     / \    / \
    10  20 15  25

Step 4: 10 is now a leaf node, sink complete
Return: 50 (the extracted maximum)
```

## Complete Example: Building and Extracting

Let's trace through a complete example with array `[10, 20, 15, 30]`:

### Building Phase:
```
Insert 10: [10]
Tree: 10

Insert 20: [10, 20] → swim → [20, 10]
Tree:  20
      /
     10

Insert 15: [20, 10, 15] (no swim needed)
Tree:  20
      / \
     10  15

Insert 30: [20, 10, 15, 30] → swim → [30, 20, 15, 10]
Tree:  30
      / \
     20  15
    /
   10
```

### Extraction Phase:
```
Extract 1: [30, 20, 15, 10] → [10, 20, 15] → sink → [20, 10, 15]
Returned: 30

Extract 2: [20, 10, 15] → [15, 10] → sink → [15, 10]  
Returned: 20

Extract 3: [15, 10] → [10] (no sink needed)
Returned: 15

Extract 4: [10] → []
Returned: 10
```

## Key Properties Summary

| Operation      | Time Complexity | Description              |
|:-------------- |:--------------:|:-------------------------|
| **Insert**     | O(log n)       | Add element, swim up     |
| **Extract Max**| O(log n)       | Remove root, sink down   |
| **Peek/Top**   | O(1)           | View max element         |
| **Size/Empty** | O(1)           | Utility operations       |

## Why Max-Heap for Priority Queue?

1. **Root Access**: Maximum element always at root (O(1) access)
2. **Efficient Operations**: Both insert and extract are O(log n)
3. **Space Efficient**: Array-based, no pointer overhead
4. **Cache Friendly**: Sequential memory access patterns
5. **Simple Implementation**: Clear parent-child relationships

## Real-World Applications

- **Operating Systems**: Process scheduling by priority
- **Gaming**: High score management
- **Task Management**: Critical tasks first
- **Network Routing**: Quality of Service (QoS)
- **Algorithms**: Dijkstra's shortest path, Prim's MST
- **Event Simulation**: Process events by timestamp

The max-heap priority queue provides an elegant solution for scenarios where you need efficient access to the "most important" element while maintaining reasonable insertion performance.
