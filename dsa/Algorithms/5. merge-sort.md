# Merge Sort Algorithm

## Overview

**Merge Sort** is a divide-and-conquer algorithm that sorts an array by recursively dividing it into smaller subarrays, sorting them, and then merging them back together.

## How Merge Sort Works

Merge Sort follows the divide-and-conquer paradigm:
1. **Divide** the array into two halves
2. **Conquer** by recursively sorting both halves
3. **Combine** by merging the two sorted halves

## Algorithm Components

### Main Function: `mergeSort(arr, l, r)`

```cpp
if (l < r) {                    // Base case: if l >= r, array has 0 or 1 element (already sorted)
    int m = l + (r - l) / 2;    // Find middle point (avoids overflow)
    mergeSort(arr, l, m);       // Recursively sort left half
    mergeSort(arr, m + 1, r);   // Recursively sort right half
    merge(arr, l, m, r);        // Merge the two sorted halves
}
```

### Merge Function: `merge(arr, l, m, r)`

This function merges two already sorted subarrays:
- Left subarray: `arr[l..m]`
- Right subarray: `arr[m+1..r]`

**Steps:**
1. **Create temporary arrays** `L[]` and `R[]` to store the two halves
2. **Copy data** from original array to temp arrays
3. **Merge back** by comparing elements from both temp arrays and placing smaller one first
4. **Copy remaining elements** from whichever array still has elements

## Example Walkthrough

Starting with array: `{38, 27, 43, 3, 9, 82, 10}`

```
Initial: [38, 27, 43, 3, 9, 82, 10]

Step 1: Divide
         [38, 27, 43, 3, 9, 82, 10]
              /                \
      [38, 27, 43]         [3, 9, 82, 10]
       /        \           /          \
   [38]      [27, 43]   [3, 9]     [82, 10]
            /     \     /    \      /     \
          [27]   [43] [3]   [9]  [82]   [10]

Step 2: Conquer (sort individual elements - already done)

Step 3: Combine (merge)
          [27]   [43] [3]   [9]  [10]   [82]
            \     /     \    /      \     /
           [27, 43]    [3, 9]     [10, 82]
              \          /           /
            [3, 9, 27, 43]     [10, 82]
                    \             /
                [3, 9, 10, 27, 43, 82]
```

## Key Points

1. **Recursive Division**: The array keeps getting divided until each subarray has only 1 element
2. **Base Case**: `if (l < r)` - when `l >= r`, we have 0 or 1 element (already sorted)
3. **Merge Process**: The `merge()` function is the heart - it combines two sorted arrays into one sorted array
4. **Stability**: Elements with equal values maintain their relative order
5. **Guaranteed Performance**: Always O(n log n) regardless of input distribution

## Complexity Analysis

### Time Complexity
- **Best Case**: O(n log n)
- **Average Case**: O(n log n)
- **Worst Case**: O(n log n)

The recurrence relation is: `T(n) = 2T(n/2) + O(n)`

### Space Complexity
- **O(n)** extra space is used for temporary arrays during the merge process

## Advantages

- **Consistent Performance**: Always O(n log n) time complexity
- **Stable**: Maintains relative order of equal elements
- **Predictable**: Performance doesn't depend on input distribution
- **Parallelizable**: Can be easily adapted for parallel processing

## Disadvantages

- **Space Overhead**: Requires O(n) extra space
- **Not In-Place**: Cannot sort the array in-place
- **Overhead for Small Arrays**: May be slower than simple algorithms for very small datasets

## When to Use

Merge Sort is ideal when:
- You need guaranteed O(n log n) performance
- Stability is required
- You have sufficient memory for the extra space
- Working with large datasets where predictable performance is crucial
