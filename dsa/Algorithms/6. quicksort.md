# Quick Sort Algorithm

## Overview

Quick Sort is a highly efficient divide-and-conquer sorting algorithm that works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.

Quick Sort is one of the most popular sorting algorithms due to its excellent average-case performance and in-place sorting capability. It was developed by Tony Hoare in 1959 and is widely used in practice.

### Key Characteristics

- **Divide-and-conquer**: Breaks the problem into smaller subproblems
- **In-place**: Uses O(1) extra space (excluding recursion stack)
- **Not stable**: Does not maintain relative order of equal elements
- **Adaptive**: Can be optimized for partially sorted arrays
- **Cache-efficient**: Good locality of reference

## How It Works

The Quick Sort algorithm follows a simple strategy:

1. **Choose a pivot**: Select an element from the array as the pivot
2. **Partition**: Rearrange the array so that:
   - All elements smaller than the pivot come before it
   - All elements greater than the pivot come after it
   - The pivot is in its final sorted position
3. **Recursively sort**: Apply the same process to the sub-arrays on both sides of the pivot

### The Divide-and-Conquer Approach

```
Original Array: [10, 7, 8, 9, 1, 5]
                          ↓
                    Choose Pivot
                          ↓
    Partition: [Elements ≤ pivot] [pivot] [Elements > pivot]
                          ↓
              Recursively sort both sides
```

## Step-by-Step Breakdown

Let's trace through the algorithm with the example array: `[10, 7, 8, 9, 1, 5]`

### Initial Call: quickSort(arr, 0, 5)

```
Array: [10, 7, 8, 9, 1, 5]
       low=0            high=5
```

### Partition Step 1

**Pivot Selection**: Choose last element as pivot
```
Array: [10, 7, 8, 9, 1, 5]
                         ↑
                     pivot=5
```

**Partitioning Process**:
- **i = -1** (index of smaller element, starts at low-1)
- **j** traverses from low to high-1

#### j=0: arr[0]=10, compare with pivot=5
- 10 ≤ 5? **No** → Don't swap, continue
- i remains -1

#### j=1: arr[1]=7, compare with pivot=5
- 7 ≤ 5? **No** → Don't swap, continue
- i remains -1

#### j=2: arr[2]=8, compare with pivot=5
- 8 ≤ 5? **No** → Don't swap, continue
- i remains -1

#### j=3: arr[3]=9, compare with pivot=5
- 9 ≤ 5? **No** → Don't swap, continue
- i remains -1

#### j=4: arr[4]=1, compare with pivot=5
- 1 ≤ 5? **Yes** → Increment i to 0, swap arr[0] and arr[4]
- Array becomes: `[1, 7, 8, 9, 10, 5]`

**Final Pivot Placement**:
- Swap arr[i+1] with arr[high]: swap arr[1] with arr[5]
- Array becomes: `[1, 5, 8, 9, 10, 7]`
- Return partition index: 1

```
After Partition: [1, 5, 8, 9, 10, 7]
                    ↑
                 pivot at index 1
```

### Recursive Calls

Now we have:
- Left subarray: `[1]` (indices 0 to 0)
- Right subarray: `[8, 9, 10, 7]` (indices 2 to 5)

#### Left Subarray: quickSort(arr, 0, 0)
- low = 0, high = 0
- Since low ≮ high, return immediately (base case)
- `[1]` is already sorted

#### Right Subarray: quickSort(arr, 2, 5)

**Partition Step 2**:
```
Subarray: [8, 9, 10, 7]
                    ↑
                pivot=7
```

Partitioning process:
- i = 1 (starts at low-1 = 2-1 = 1)

##### j=2: arr[2]=8, compare with pivot=7
- 8 ≤ 7? **No** → Don't swap

##### j=3: arr[3]=9, compare with pivot=7
- 9 ≤ 7? **No** → Don't swap

##### j=4: arr[4]=10, compare with pivot=7
- 10 ≤ 7? **No** → Don't swap

**Final Pivot Placement**:
- Swap arr[i+1] with arr[high]: swap arr[2] with arr[5]
- Array becomes: `[1, 5, 7, 9, 10, 8]`
- Return partition index: 2

#### Further Recursive Calls

**Left of pivot 7**: quickSort(arr, 2, 1)
- Since low ≮ high, return (base case)

**Right of pivot 7**: quickSort(arr, 3, 5) → `[9, 10, 8]`

This continues recursively until all subarrays are sorted.

### Final Result
```
Sorted Array: [1, 5, 7, 8, 9, 10]
```

## Code Analysis

### Partition Function Breakdown

```cpp
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];     // Choose last element as pivot
    int i = low - 1;           // Index of smaller element
    
    for (int j = low; j < high; ++j) {
        if (arr[j] <= pivot) {     // If current element ≤ pivot
            ++i;                   // Increment index of smaller element
            std::swap(arr[i], arr[j]); // Swap elements
        }
    }
    std::swap(arr[i + 1], arr[high]); // Place pivot in correct position
    return i + 1;                     // Return partition index
}
```

#### Key Variables in Partition

- **`pivot`**: The chosen pivot element (last element in this implementation)
- **`i`**: Index of the rightmost element that is ≤ pivot
- **`j`**: Current element being compared with pivot
- **`low, high`**: Boundaries of the current subarray

#### Partition Logic

The partition function maintains this invariant:
```
[≤ pivot] [> pivot] [unprocessed] [pivot]
↑         ↑         ↑             ↑
low       i+1       j             high
```

### QuickSort Function Breakdown

```cpp
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {                    // Base case check
        int pi = partition(arr, low, high); // Partition and get pivot index
        
        quickSort(arr, low, pi - 1);     // Sort left subarray
        quickSort(arr, pi + 1, high);    // Sort right subarray
    }
}
```

#### Recursion Tree Example

For array `[10, 7, 8, 9, 1, 5]`:

```
                quickSort(0, 5)
                      |
                 partition → pivot at index 1
                /                    \
        quickSort(0, 0)          quickSort(2, 5)
         (base case)                    |
                                 partition → pivot at index 2
                                /                    \
                        quickSort(2, 1)          quickSort(3, 5)
                         (base case)                    |
                                                partition → and so on...
```

## Time Complexity Analysis

### Best Case: O(n log n)
- Occurs when the pivot always divides the array into two equal halves
- Recursion depth: log n
- Work at each level: O(n) for partitioning
- Total: O(n log n)

**Recurrence Relation**: T(n) = 2T(n/2) + O(n)

### Average Case: O(n log n)
- On average, the pivot divides the array into reasonably balanced partitions
- Even if the split is not exactly equal (e.g., 1/3 and 2/3), the complexity remains O(n log n)

### Worst Case: O(n²)
- Occurs when the pivot is always the smallest or largest element
- This happens when:
  - Array is already sorted (ascending or descending)
  - All elements are equal
- Recursion depth: O(n)
- Work at each level: O(n)
- Total: O(n²)

**Recurrence Relation**: T(n) = T(n-1) + O(n)

## Space Complexity: O(log n)

Quick Sort is an in-place sorting algorithm, but it uses space for the recursion stack:

- **Best/Average Case**: O(log n) - balanced recursion tree
- **Worst Case**: O(n) - skewed recursion tree (one side always empty)

The space complexity comes from the call stack, not from additional arrays.

## Pivot Selection Strategies

### 1. Last Element (Used in our implementation)
```cpp
int pivot = arr[high];
```
- **Pros**: Simple to implement
- **Cons**: Poor performance on sorted arrays

### 2. First Element
```cpp
int pivot = arr[low];
```
- Similar trade-offs to last element

### 3. Random Element
```cpp
int randomIndex = low + rand() % (high - low + 1);
std::swap(arr[randomIndex], arr[high]);
int pivot = arr[high];
```
- **Pros**: Expected O(n log n) performance
- **Cons**: Requires random number generation

### 4. Median-of-Three
```cpp
int mid = low + (high - low) / 2;
if (arr[mid] < arr[low]) std::swap(arr[low], arr[mid]);
if (arr[high] < arr[low]) std::swap(arr[low], arr[high]);
if (arr[high] < arr[mid]) std::swap(arr[mid], arr[high]);
int pivot = arr[high];
```
- **Pros**: Better performance on partially sorted arrays
- **Cons**: Slightly more complex

## Advantages

1. **Efficient on average**: O(n log n) average time complexity
2. **In-place**: Uses only O(1) extra space (excluding recursion)
3. **Cache-efficient**: Good locality of reference
4. **Practical**: Often faster than other O(n log n) algorithms in practice
5. **Widely used**: Standard library implementations (like std::sort often use variants)

## Disadvantages

1. **Worst-case performance**: O(n²) in the worst case
2. **Not stable**: Does not preserve relative order of equal elements
3. **Recursion overhead**: Uses recursion stack space
4. **Pivot selection**: Performance depends heavily on pivot choice

## Optimizations

### 1. Hybrid Approach
Switch to insertion sort for small subarrays (typically < 10-20 elements):

```cpp
if (high - low < THRESHOLD) {
    insertionSort(arr, low, high);
    return;
}
```

### 2. Iterative Implementation
Replace recursion with explicit stack to avoid stack overflow:

```cpp
std::stack<std::pair<int, int>> stack;
stack.push({low, high});
// Process stack iteratively
```

### 3. Three-Way Partitioning
Handle arrays with many duplicate elements efficiently (Dutch National Flag algorithm).

## Variants

1. **Randomized Quick Sort**: Uses random pivot selection
2. **Three-Way Quick Sort**: Handles duplicates efficiently
3. **Intro Sort**: Hybrid of quick sort, heap sort, and insertion sort (used in many standard libraries)

## When to Use Quick Sort

**Use Quick Sort when**:
- You need good average-case performance
- Memory usage is a concern (in-place sorting)
- The data is randomly distributed
- You need a general-purpose sorting algorithm

**Avoid Quick Sort when**:
- Worst-case performance guarantees are critical
- Stability is required
- The data is already sorted or nearly sorted (without optimizations)

## Comparison with Other Sorting Algorithms
| Algorithm      | Best Case   | Average Case | Worst Case | Space     | Stable | In-Place |
|:-------------- |:-----------:|:------------:|:----------:|:---------:|:------:|:--------:|
| Quick Sort     | O(n log n)  | O(n log n)   | O(n²)      | O(log n)  |   No   |   Yes    |
| Merge Sort     | O(n log n)  | O(n log n)   | O(n log n) |   O(n)    |  Yes   |    No    |
| Heap Sort      | O(n log n)  | O(n log n)   | O(n log n) |   O(1)    |   No   |   Yes    |
| Insertion Sort |   O(n)      |   O(n²)      |   O(n²)    |   O(1)    |  Yes   |   Yes    |
| Selection Sort |   O(n²)     |   O(n²)      |   O(n²)    |   O(1)    |   No   |   Yes    |

## Real-World Applications

1. **Standard Libraries**: Many programming languages use Quick Sort variants in their standard libraries
2. **Database Systems**: Used for sorting operations in database query processing
3. **Graphics**: Sorting objects by depth for rendering
4. **Numerical Computing**: Sorting arrays in scientific computations

## Conclusion

Quick Sort is one of the most important and widely used sorting algorithms. Its excellent average-case performance, in-place nature, and cache efficiency make it a go-to choice for many applications. While it has some drawbacks (worst-case O(n²) performance and lack of stability), these can often be mitigated through careful implementation and hybrid approaches.

Understanding Quick Sort is essential for any programmer, as it demonstrates key algorithmic concepts like divide-and-conquer, recursion, and the trade-offs between different design choices. Its elegance lies in its simplicity—with just a few lines of code, it can efficiently sort large amounts of data.
